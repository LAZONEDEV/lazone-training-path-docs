"use strict";(self.webpackChunklazone_learning_path=self.webpackChunklazone_learning_path||[]).push([[8252],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(a),h=n,m=d["".concat(s,".").concat(h)]||d[h]||u[h]||i;return a?r.createElement(m,o(o({ref:t},c),{},{components:a})):r.createElement(m,o({ref:t},c))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:n,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}h.displayName="MDXCreateElement"},9604:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=a(7462),n=(a(7294),a(3905));const i={sidebar_position:5,title:"REST API vs GraphQL API"},o="Comparison between REST API and GraphQL API",l={unversionedId:"tutorial-basics/comparaison-rest-and-graphql",id:"version-1.0/tutorial-basics/comparaison-rest-and-graphql",title:"REST API vs GraphQL API",description:"REST (Representational State Transfer) APIs and GraphQL APIs are two different approaches to designing interfaces for web services. Each has its own advantages and is suitable for specific use cases. Here's a comparison between the two:",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-1.0/tutorial-basics/comparaison-rest-and-graphql.md",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/comparaison-rest-and-graphql",permalink:"/lazone-training-path-docs/en/docs/tutorial-basics/comparaison-rest-and-graphql",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-1.0/tutorial-basics/comparaison-rest-and-graphql.md",tags:[],version:"1.0",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"REST API vs GraphQL API"},sidebar:"tutorialSidebar",previous:{title:"Understanding GraphQL APIs",permalink:"/lazone-training-path-docs/en/docs/tutorial-basics/introduction-api-graphql"},next:{title:"NodeJS Tutorial",permalink:"/lazone-training-path-docs/en/docs/category/nodejs-tutorial"}},s={},p=[{value:"Architecture",id:"architecture",level:2},{value:"REST API",id:"rest-api",level:3},{value:"GraphQL API",id:"graphql-api",level:3},{value:"Query Flexibility",id:"query-flexibility",level:2},{value:"REST API",id:"rest-api-1",level:3},{value:"GraphQL API",id:"graphql-api-1",level:3},{value:"Performance",id:"performance",level:2},{value:"REST API",id:"rest-api-2",level:3},{value:"GraphQL API",id:"graphql-api-2",level:3},{value:"Versioning",id:"versioning",level:2},{value:"REST API",id:"rest-api-3",level:3},{value:"GraphQL API",id:"graphql-api-3",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...a}=e;return(0,n.kt)(d,(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"comparison-between-rest-api-and-graphql-api"},"Comparison between REST API and GraphQL API"),(0,n.kt)("p",null,"REST (Representational State Transfer) APIs and GraphQL APIs are two different approaches to designing interfaces for web services. Each has its own advantages and is suitable for specific use cases. Here's a comparison between the two:"),(0,n.kt)("h2",{id:"architecture"},"Architecture"),(0,n.kt)("h3",{id:"rest-api"},"REST API"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Resource-based architecture:")," Resources (e.g., ",(0,n.kt)("inlineCode",{parentName:"li"},"/users"),", ",(0,n.kt)("inlineCode",{parentName:"li"},"/articles"),") are exposed as distinct endpoints."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Single endpoint for each resource:")," Each resource typically has a dedicated endpoint (URL) for CRUD operations.")),(0,n.kt)("h3",{id:"graphql-api"},"GraphQL API"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Graph-based architecture:")," Data is modeled as a graph, where relationships between entities are clearly defined."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Single endpoint for all queries:")," A single URL is used for all GraphQL queries, with a schema describing types and possible operations.")),(0,n.kt)("h2",{id:"query-flexibility"},"Query Flexibility"),(0,n.kt)("h3",{id:"rest-api-1"},"REST API"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Predefined data:")," REST endpoints return predefined data, usually in JSON format."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Information overload:")," Clients may receive more information than needed, leading to bandwidth overload.")),(0,n.kt)("h3",{id:"graphql-api-1"},"GraphQL API"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Custom queries:")," Clients specify exactly the data they need, avoiding unnecessary information overload."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Optimized data retrieval:")," Clients can get all necessary data in a single query.")),(0,n.kt)("h2",{id:"performance"},"Performance"),(0,n.kt)("h3",{id:"rest-api-2"},"REST API"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Under-fetching and over-fetching:")," Clients may suffer from under-fetching (not enough data) or over-fetching (too much data) depending on the design of endpoints.")),(0,n.kt)("h3",{id:"graphql-api-2"},"GraphQL API"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Avoids under-fetching and over-fetching:")," Clients get exactly the data they need, avoiding issues of under-fetching or over-fetching.")),(0,n.kt)("h2",{id:"versioning"},"Versioning"),(0,n.kt)("h3",{id:"rest-api-3"},"REST API"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Explicit versioning:")," Often, versioning is managed by adding a version to the URL (e.g., ",(0,n.kt)("inlineCode",{parentName:"li"},"/v1/users"),").")),(0,n.kt)("h3",{id:"graphql-api-3"},"GraphQL API"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Schema evolution:")," Changes in the GraphQL schema can be managed more flexibly, avoiding the need for explicit versioning in the URL.")),(0,n.kt)("h2",{id:"conclusion"},"Conclusion"),(0,n.kt)("p",null,"In summary, the choice between a REST API and a GraphQL API depends on the specific needs of the project. REST APIs offer a straightforward resource-based approach, while GraphQL APIs provide increased flexibility by allowing clients to specify the exact data they need. Choosing between the two depends on the context, application requirements, and development team preferences."))}u.isMDXComponent=!0}}]);